<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Hyperledger Fabric Contract API and Shim for node.js chaincode Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsefabric-shim.X509Certificate Tutorials Getting StartedUsing the Chaincode InterfaceUsing the Contract Interface Classes Classes Context Contract ChaincodeInterface ChaincodeProposalPayload ChaincodeStub ChannelHeader ClientIdentity CommonIterator ErrorResponse FunctionAndParameters Header HistoryQueryIterator Proposal ProposalCreator Response Shim SignatureHeader SignedProposal StateQueryIterator SuccessResponse X509Certificate × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-09-06T09:41:32+01:00 using the DocStrap template. "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Hyperledger Fabric Contract API and Shim for node.js chaincode Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsefabric-shim.X509Certificate Tutorials Getting StartedUsing the Chaincode InterfaceUsing the Contract Interface Tutorials Classes Context Contract ChaincodeInterface ChaincodeProposalPayload ChaincodeStub ChannelHeader ClientIdentity CommonIterator ErrorResponse FunctionAndParameters Header HistoryQueryIterator Proposal ProposalCreator Response Shim SignatureHeader SignedProposal StateQueryIterator SuccessResponse X509Certificate × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-09-06T09:41:32+01:00 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Hyperledger Fabric Contract API and Shim for node.js chaincode Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsefabric-shim.X509Certificate Tutorials Getting StartedUsing the Chaincode InterfaceUsing the Contract Interface The fabric-contract-api provides the contract interface. a high level API for application developers to implement Smart Contracts. Within Hyperledger Fabric, Smart Contracts are also known as Chaincode. Working with this API provides a high level entry point to writing business logic. (this contract interface is new in version 1.3) The fabric-shim provides the chaincode interface, a lower level API for implementing &quot;Smart Contracts&quot;. It also currently provides the implementation to support communication with Hyperledger Fabric peers for Smart Contracts written using the fabric-contract-api. To confirm that this is the same as the fabric-shim in previous versions of Hyperledger Fabric. Detailed explanation on the concept and programming model can be found here: http://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html. Contract InterfaceInstallationnpm install --save fabric-contract-apiUsageImplement a class that ends the contract class, a contsturctor is needed. The other functions will be invokable functions of your Smart Contract // updatevalues.js 'use strict'; // SDK Library to asset with writing the logic const { Contract } = require('fabric-contract-api'); // Business logic (well just util but still it's general purpose logic) const util = require('util'); /** * Support the Updating of values within the SmartContract */ class UpdateValuesContract extends Contract constructor(){ super('org.mynamespace.updates'); } async transactionA(ctx, newValue) { // retrieve existing chaincode states let oldValue = await ctx.stub.getState(key); await ctx.stub.putState(key, Buffer.from(newValue)); return Buffer.from(newValue.toString()); } async transactionB(ctx) { // ..... } }; module.exports = UpdateValuesContractAs with standard node modules make sure that this class is exported as follows. // index.js 'use strict'; const UpdateValues = require('./updatevalues') module.exports.contracts = ['UpdateValues'];Note: In order to make this contract runnable in version 1.3, also install the fabric-shim module as below, and ensure that the 'start' script in package.json refers to startChaincode &quot;scripts&quot;: { &quot;start&quot;: &quot;startChaincode&quot; }Chaincode InterfaceInstallationnpm install --save fabric-shimUsageThe chaincode interface contains two methods to be implemented: const shim = require('fabric-shim'); const Chaincode = class { async Init(stub) { // use the instantiate input arguments to decide initial chaincode state values // save the initial states await stub.putState(key, Buffer.from(aStringValue)); return shim.success(Buffer.from('Initialized Successfully!')); } async Invoke(stub) { // use the invoke input arguments to decide intended changes // retrieve existing chaincode states let oldValue = await stub.getState(key); // calculate new state values and saves them let newValue = oldValue + delta; await stub.putState(key, Buffer.from(newValue)); return shim.success(Buffer.from(newValue.toString())); } };Start the chaincode process and listen for incoming endorsement requests: shim.start(new Chaincode());API ReferenceVisit fabric-shim.github.io and click on &quot;Classes&quot; link in the navigation bar on the top to view the list of class APIs. SupportTested with node.js 8.9.0 (LTS). LicenseThis package is distributed under the Apache License, Version 2.0, see LICENSE.txt for more information. × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-09-06T09:41:32+01:00 using the DocStrap template. "},"fabric-contract-api.Context.html":{"id":"fabric-contract-api.Context.html","title":"Class: Context","body":" Hyperledger Fabric Contract API and Shim for node.js chaincode Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsefabric-shim.X509Certificate Tutorials Getting StartedUsing the Chaincode InterfaceUsing the Contract Interface Class: Context Context The Context class provides the transactional context per a transactional execution. This can be subclassed to provided additional functional behaviour to support smart contract execution. An example would be to provide additional help to map application object ids to world state composite keys. In the constructor, do not reference the stub or clientidentity functions. new Context() Example class ScenarioContext extends Context{ constructor(){ super(); } generateKey(){ return this.stub.createCompositeKey('type',['keyvalue']); } } Methods setChaincodeStub(stub) This sets the chaincode stub object with api to use for worldstate access. MUST NOT BE CALLED FROM SMART CONTRACT CODE Parameters: Name Type Description stub ChaincodeStub chaincode stub instance setClientIdentity(clientIdentity) This sets the ClientIdentity object to use for information on the transaction invoking identity MUST NOT BE CALLED FROM SMART CONTRACT CODE Parameters: Name Type Description clientIdentity ClientIdentity chaincode stub instance × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-09-06T09:41:32+01:00 using the DocStrap template. "},"fabric-contract-api.Contract.html":{"id":"fabric-contract-api.Contract.html","title":"Class: Contract","body":" Hyperledger Fabric Contract API and Shim for node.js chaincode Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsefabric-shim.X509Certificate Tutorials Getting StartedUsing the Chaincode InterfaceUsing the Contract Interface Class: Contract Contract The main Contact class that all code working within a Chaincode Container must be extending. Overriding of the `beforeTransaction` `afterTransaction` `unknownTransaction` and `createContext` are all optional Supplying a namespace within the constructor is also option and will default to '' new Contract(namespace) Constructor - supplying a namespace is recommended but is not mandatory. Parameters: Name Type Description namespace String namespace for the logic within this contract Methods &lt;async&gt; afterTransaction(ctx, result) 'afterTransaction' will be called before any of the transaction functions within your contract Override this method to implement your own processing. Examples of what you may wish to code are Logging, Event Publishing If an error is thrown, the whole transaction will be rejected Parameters: Name Type Description ctx Context the transactional context result Object value that is returned from the transaction function &lt;async&gt; beforeTransaction(ctx) 'beforeTransaction' will be called before any of the transaction functions within your contract Override this method to implement your own processing. Examples of what you may wish to code are Logging, Event Publishing or Permissions checks If an error is thrown, the whole transaction will be rejected Parameters: Name Type Description ctx Context the transactional context createContext() 'createContext' is called before any after, before, unknown or user defined transaction function. This permits contracts to use their own subclass of context to add additinal processing. After this function returns, the chaincodeStub and client identity objects will be injected. No chaincode apis are available for calling directly within this function. Nor should the constructor of the subclasses context assume any other setup. Returns: a context implementation that must subclass context Type Context getNamespace() Returns: returns the namepsace Type String &lt;async&gt; unknownTransaction(ctx) 'unknownTransaction' will be called if the required transaction function requested does not exist Override this method to implement your own processing. * If an error is thrown, the whole transaction will be rejected Parameters: Name Type Description ctx Context the transactional context × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-09-06T09:41:32+01:00 using the DocStrap template. "},"fabric-shim.ChaincodeInterface.html":{"id":"fabric-shim.ChaincodeInterface.html","title":"Class: ChaincodeInterface","body":" Hyperledger Fabric Contract API and Shim for node.js chaincode Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsefabric-shim.X509Certificate Tutorials Getting StartedUsing the Chaincode InterfaceUsing the Contract Interface Class: ChaincodeInterface ChaincodeInterface Chaincodes must implement the methods in this interface. The Init() method is called during chaincode instantiation or upgrade to preform any necessary intitialization of the application state. Invoke() is called by invoke transaction or query requests. Both methods are provided with a stub object that can be used to discover information on the request (invoking identity, target channel, arguments, etc.) as well as talking with the peer to retrieve or update application state. new ChaincodeInterface() Methods &lt;async&gt; Init(stub) Called during chaincode instantiate and upgrade. This method can be used to initialize asset states Parameters: Name Type Description stub ChaincodeStub The chaincode stub is implemented by the fabric-shim library and passed to the ChaincodeInterface calls by the Hyperledger Fabric platform. The stub encapsulates the APIs between the chaincode implementation and the Fabric peer &lt;async&gt; Invoke(stub) called throughout the life time of the chaincode to carry out business transaction logic and effect the asset states Parameters: Name Type Description stub ChaincodeStub The chaincode stub is implemented by the fabric-shim library and passed to the ChaincodeInterface calls by the Hyperledger Fabric platform. The stub encapsulates the APIs between the chaincode implementation and the Fabric peer × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-09-06T09:41:32+01:00 using the DocStrap template. "},"fabric-shim.ChaincodeProposalPayload.html":{"id":"fabric-shim.ChaincodeProposalPayload.html","title":"Class: ChaincodeProposalPayload","body":" Hyperledger Fabric Contract API and Shim for node.js chaincode Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsefabric-shim.X509Certificate Tutorials Getting StartedUsing the Chaincode InterfaceUsing the Contract Interface Class: ChaincodeProposalPayload ChaincodeProposalPayload new ChaincodeProposalPayload() Properties: Name Type Description input Buffer Input contains the arguments for this invocation. If this invocation deploys a new chaincode, ESCC/VSCC are part of this field. This is usually a marshaled ChaincodeInvocationSpec transientMap Map.&lt;string:Buffer&gt; TransientMap contains data (e.g. cryptographic material) that might be used to implement some form of application-level confidentiality. The contents of this field are supposed to always be omitted from the transaction and excluded from the ledger. × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-09-06T09:41:32+01:00 using the DocStrap template. "},"fabric-shim.ChaincodeStub.html":{"id":"fabric-shim.ChaincodeStub.html","title":"Class: ChaincodeStub","body":" Hyperledger Fabric Contract API and Shim for node.js chaincode Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsefabric-shim.X509Certificate Tutorials Getting StartedUsing the Chaincode InterfaceUsing the Contract Interface Class: ChaincodeStub ChaincodeStub The ChaincodeStub is implemented by the fabric-shim library and passed to the ChaincodeInterface calls by the Hyperledger Fabric platform. The stub encapsulates the APIs between the chaincode implementation and the Fabric peer new ChaincodeStub(client, channel_id, txId, chaincodeInput, signedProposal) Parameters: Name Type Description client Handler an instance of the Handler class channel_id string channel id txId string transaction id chaincodeInput any decoded message from peer signedProposal any the proposal Methods createCompositeKey(objectType, attributes) Creates a composite key by combining the objectType string and the given `attributes` to form a composite key. The objectType and attributes are expected to have only valid utf8 strings and should not contain U+0000 (nil byte) and U+10FFFF (biggest and unallocated code point). The resulting composite key can be used as the key in putState(). Hyperledger Fabric uses a simple key/value model for saving chaincode states. In some use case scenarios, it is necessary to keep track of multiple attributes. Furthermore, it may be necessary to make the various attributes searchable. Composite keys can be used to address these requirements. Similar to using composite keys in a relational database table, here you would treat the searchable attributes as key columns that make up the composite key. Values for the attributes become part of the key, thus they are searchable with functions like getStateByRange() and getStateByPartialCompositeKey(). Parameters: Name Type Description objectType string A string used as the prefix of the resulting key attributes Array.&lt;string&gt; List of attribute values to concatenate into the key Returns: A composite key with the objectType and the array of attributes joined together with special delimiters that will not be confused with values of the attributes Type string &lt;async&gt; deletePrivateData(collection, key) deletePrivateData records the specified `key` to be deleted in the private writeset of the transaction. Note that only hash of the private writeset goes into the transaction proposal response (which is sent to the client who issued the transaction) and the actual private writeset gets temporarily stored in a transient store. The `key` and its value will be deleted from the collection when the transaction is validated and successfully committed. Parameters: Name Type Description collection string The collection name key string Private data variable key to delete from the state store &lt;async&gt; deleteState(key) Deletes the state variable key from the state store. Parameters: Name Type Description key string State variable key to delete from the state store Returns: Promise will be resolved when the peer has successfully handled the state delete request or rejected if any errors Type Promise getArgs() Returns the arguments as array of strings from the chaincode invocation request. Equivalent to getStringArgs() Returns: Type Array.&lt;string&gt; getBinding() Returns a HEX-encoded string of SHA256 hash of the transaction's nonce, creator and epoch concatenated, as a unique representation of the specific transaction. This value can be used to prevent replay attacks in chaincodes that need to authenticate an identity independent of the transaction's submitter. In a chaincode proposal, the submitter will have been authenticated by the peer such that the identity returned by stub.getCreator() can be trusted. But in some scenarios, the chaincode needs to authenticate an identity independent of the proposal submitter. For example, Alice is the administrator who installs and instantiates a chaincode that manages assets. During instantiate Alice assigns the initial owner of the asset to Bob. The chaincode has a function called transfer() that moves the asset to another identity by changing the asset's &quot;owner&quot; property to the identity receiving the asset. Naturally only Bob, the current owner, is supposed to be able to call that function. While the chaincode can rely on stub.getCreator() to check the submitter's identity and compare that with the current owner, sometimes it's not always possible for the asset owner itself to submit the transaction. Let's suppose Bob hires a broker agency to handle his trades. The agency participates in the blockchain network and carry out trades on behalf of Bob. The chaincode must have a way to authenticate the transaction to ensure it has Bob's authorization to do the asset transfer. This can be achieved by asking Bob to sign the message, so that the chaincode can use Bob's certificate, which was obtained during the chaincode instantiate, to verify the signature and thus ensure the trade was authorized by Bob. Now, to prevent Bob's signature from being re-used in a malicious attack, we want to ensure the signature is unique. This is where the binding concept comes in. As explained above, the binding string uniquely represents the transaction where the trade proposal and Bob's authorization is submitted in. As long as Bob's signature is over the proposal payload and the binding string concatenated together, namely sigma=Sign(BobSigningKey, tx.Payload||tx.Binding), it's guaranteed to be unique and can not be re-used in a different transaction for exploitation. Returns: A HEX-encoded string of SHA256 hash of the transaction's nonce, creator and epoch concatenated Type string getChannelID() Returns the channel ID for the proposal for chaincode to process. This would be the 'channel_id' of the transaction proposal (see ChannelHeader in protos/common/common.proto) except where the chaincode is calling another on a different channel. getCreator() Returns the identity object of the chaincode invocation's submitter Returns: Type ProposalCreator getFunctionAndParameters() Returns an object containing the chaincode function name to invoke, and the array of arguments to pass to the target function Returns: Type FunctionAndParameters &lt;async&gt; getHistoryForKey(key) Returns a history of key values across time. For each historic key update, the historic value and associated transaction id and timestamp are returned. The timestamp is the timestamp provided by the client in the proposal header. This method requires peer configuration core.ledger.history.enableHistoryDatabase to be true. The query is NOT re-executed during validation phase, phantom reads are not detected. That is, other committed transactions may have updated the key concurrently, impacting the result set, and this would not be detected at validation/commit time. Applications susceptible to this should therefore not use GetHistoryForKey as part of transactions that update ledger, and should limit use to read-only chaincode operations. Parameters: Name Type Description key string The state variable key Returns: Promise for a HistoryQueryIterator object Type Promise &lt;async&gt; getPrivateData(collection, key) getPrivateData returns the value of the specified `key` from the specified `collection`. Note that GetPrivateData doesn't read data from the private writeset, which has not been committed to the `collection`. In other words, GetPrivateData doesn't consider data modified by PutPrivateData that has not been committed. Parameters: Name Type Description collection string The collection name key string Private data variable key to retrieve from the state store Returns: Promise for the private value from the state store Type Promise.&lt;Array.&lt;byte&gt;&gt; &lt;async&gt; getPrivateDataByPartialCompositeKey(collection, objectType, attributes) getPrivateDataByPartialCompositeKey queries the state in a given private collection based on a given partial composite key. This function returns an iterator which can be used to iterate over all composite keys whose prefix matches the given partial composite key. The `objectType` and attributes are expected to have only valid utf8 strings and should not contain U+0000 (nil byte) and U+10FFFF (biggest and unallocated code point). See related functions SplitCompositeKey and CreateCompositeKey. Call Close() on the returned StateQueryIteratorInterface object when done. The query is re-executed during validation phase to ensure result set has not changed since transaction endorsement (phantom reads detected). Parameters: Name Type Description collection string The collection name objectType string A string used as the prefix of the resulting key attributes Array.&lt;string&gt; List of attribute values to concatenate into the partial composite key &lt;async&gt; getPrivateDataByRange(collection, startKey, endKey) getPrivateDataByRange returns a range iterator over a set of keys in a given private collection. The iterator can be used to iterate over all keys between the startKey (inclusive) and endKey (exclusive). The keys are returned by the iterator in lexical order. Note that startKey and endKey can be empty string, which implies unbounded range query on start or end. Call Close() on the returned StateQueryIteratorInterface object when done. The query is re-executed during validation phase to ensure result set has not changed since transaction endorsement (phantom reads detected). Parameters: Name Type Description collection string The collection name startKey string Private data variable key as the start of the key range (inclusive) endKey string Private data variable key as the end of the key range (exclusive) &lt;async&gt; getPrivateDataQueryResult(collection, query) getPrivateDataQueryResult performs a &quot;rich&quot; query against a given private collection. It is only supported for state databases that support rich query, e.g.CouchDB. The query string is in the native syntax of the underlying state database. An iterator is returned which can be used to iterate (next) over the query result set. The query is NOT re-executed during validation phase, phantom reads are not detected. That is, other committed transactions may have added, updated, or removed keys that impact the result set, and this would not be detected at validation/commit time. Applications susceptible to this should therefore not use GetQueryResult as part of transactions that update ledger, and should limit use to read-only chaincode operations. Parameters: Name Type Description collection string The collection name query string The query to be performed Returns: Promise for a PrivateQueryIterator object Type Promise &lt;async&gt; getQueryResult(query) Performs a &quot;rich&quot; query against a state database. It is only supported for state databases that support rich query, e.g. CouchDB. The query string is in the native syntax of the underlying state database. An StateQueryIterator is returned which can be used to iterate (next) over the query result set. The query is NOT re-executed during validation phase, phantom reads are not detected. That is, other committed transactions may have added, updated, or removed keys that impact the result set, and this would not be detected at validation/commit time. Applications susceptible to this should therefore not use GetQueryResult as part of transactions that update ledger, and should limit use to read-only chaincode operations. Parameters: Name Type Description query string Query string native to the underlying state database Returns: Promise for a StateQueryIterator object Type Promise getSignedProposal() Returns a fully decoded object of the signed transaction proposal Returns: Type SignedProposal &lt;async&gt; getState(key) Retrieves the current value of the state variable key Parameters: Name Type Description key string State variable key to retrieve from the state store Returns: Promise for the current value of the state variable Type Promise.&lt;Array.&lt;byte&gt;&gt; &lt;async&gt; getStateByPartialCompositeKey(objectType, attributes) Queries the state in the ledger based on a given partial composite key. This function returns an iterator which can be used to iterate over all composite keys whose prefix matches the given partial composite key. The `objectType` and attributes are expected to have only valid utf8 strings and should not contain U+0000 (nil byte) and U+10FFFF (biggest and unallocated code point). See related functions splitCompositeKey and createCompositeKey. Call close() on the returned StateQueryIterator object when done. The query is re-executed during validation phase to ensure result set has not changed since transaction endorsement (phantom reads detected). Parameters: Name Type Description objectType string A string used as the prefix of the resulting key attributes Array.&lt;string&gt; List of attribute values to concatenate into the partial composite key Returns: A promise that resolves with a StateQueryIterator, rejects if an error occurs Type Promise &lt;async&gt; getStateByRange(startKey, endKey) Returns a range iterator over a set of keys in the ledger. The iterator can be used to iterate over all keys between the startKey (inclusive) and endKey (exclusive). The keys are returned by the iterator in lexical order. Note that startKey and endKey can be empty string, which implies unbounded range query on start or end. Call close() on the returned StateQueryIterator object when done. The query is re-executed during validation phase to ensure result set has not changed since transaction endorsement (phantom reads detected). Parameters: Name Type Description startKey string State variable key as the start of the key range (inclusive) endKey string State variable key as the end of the key range (exclusive) Returns: Promise for a StateQueryIterator object Type Promise getStringArgs() Returns the arguments as array of strings from the chaincode invocation request Returns: Type Array.&lt;string&gt; getTransient() Returns the transient map that can be used by the chaincode but not saved in the ledger, such as cryptographic information for encryption and decryption Returns: Type Map.&lt;string:Buffer&gt; getTxID() Returns the transaction ID for the current chaincode invocation request. The transaction ID uniquely identifies the transaction within the scope of the channel. getTxTimestamp() Returns the timestamp when the transaction was created. This is taken from the transaction ChannelHeader, therefore it will indicate the client's timestamp, and will have the same value across all endorsers. &lt;async&gt; invokeChaincode(chaincodeName, args, channel) Locally calls the specified chaincode invoke() using the same transaction context; that is, chaincode calling chaincode doesn't create a new transaction message. If the called chaincode is on the same channel, it simply adds the called chaincode read set and write set to the calling transaction. If the called chaincode is on a different channel, only the Response is returned to the calling chaincode; any PutState calls from the called chaincode will not have any effect on the ledger; that is, the called chaincode on a different channel will not have its read set and write set applied to the transaction. Only the calling chaincode's read set and write set will be applied to the transaction. Effectively the called chaincode on a different channel is a `Query`, which does not participate in state validation checks in subsequent commit phase. If `channel` is empty, the caller's channel is assumed. Parameters: Name Type Description chaincodeName string Name of the chaincode to call args Array.&lt;Array.&lt;byte&gt;&gt; List of arguments to pass to the called chaincode channel string Name of the channel where the target chaincode is active Returns: Promise for a Response object returned by the called chaincode Type Promise &lt;async&gt; putPrivateData(collection, key, value) putPrivateData puts the specified `key` and `value` into the transaction's private writeSet. Note that only hash of the private writeSet goes into the transaction proposal response (which is sent to the client who issued the transaction) and the actual private writeSet gets temporarily stored in a transient store. PutPrivateData doesn't effect the `collection` until the transaction is validated and successfully committed. Simple keys must not be an empty string and must not start with null character (0x00), in order to avoid range query collisions with composite keys, which internally get prefixed with 0x00 as composite key namespace. Parameters: Name Type Description collection string The collection name key string Private data variable key to set the value for value string | Array.&lt;byte&gt; Private data variable value &lt;async&gt; putState(key, value) Writes the state variable key of value value to the state store. If the variable already exists, the value will be overwritten. Parameters: Name Type Description key string State variable key to set the value for value Array.&lt;byte&gt; | string State variable value Returns: Promise will be resolved when the peer has successfully handled the state update request or rejected if any errors Type Promise setEvent(name, payload) Allows the chaincode to propose an event on the transaction proposal. When the transaction is included in a block and the block is successfully committed to the ledger, the block event will be delivered to the current event listeners that have been registered with the peer's event producer. Note that the block event gets delivered to the listeners regardless of the status of the included transactions (can be either valid or invalid), so client applications are responsible for checking the validity code on each transaction. Consult each SDK's documentation for details. Parameters: Name Type Description name string Name of the event payload Array.&lt;byte&gt; A payload can be used to include data about the event splitCompositeKey(compositeKey) Splits the specified key into attributes on which the composite key was formed. Composite keys found during range queries or partial composite key queries can therefore be split into their original composite parts, essentially recovering the values of the attributes. Parameters: Name Type Description compositeKey string The composite key to split Returns: An object which has properties of 'objectType' (string) and 'attributes' (string[]) Type Object × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-09-06T09:41:32+01:00 using the DocStrap template. "},"fabric-shim.ChannelHeader.html":{"id":"fabric-shim.ChannelHeader.html","title":"Class: ChannelHeader","body":" Hyperledger Fabric Contract API and Shim for node.js chaincode Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsefabric-shim.X509Certificate Tutorials Getting StartedUsing the Chaincode InterfaceUsing the Contract Interface Class: ChannelHeader ChannelHeader new ChannelHeader() Channel header identifies the destination channel of the invocation request and the type of request etc. Properties: Name Type Description type number Any of the following: MESSAGE = 0; // Used for messages which are signed but opaque CONFIG = 1; // Used for messages which express the channel config CONFIG_UPDATE = 2; // Used for transactions which update the channel config ENDORSER_TRANSACTION = 3; // Used by the SDK to submit endorser based transactions ORDERER_TRANSACTION = 4; // Used internally by the orderer for management DELIVER_SEEK_INFO = 5; // Used as the type for Envelope messages submitted to instruct the Deliver API to seek CHAINCODE_PACKAGE = 6; // Used for packaging chaincode artifacts for install version number timestamp google.protobuf.Timestamp The local time when the message was created by the submitter channel_id string Identifier of the channel that this message bound for tx_id string Unique identifier used to track the transaction throughout the proposal endorsement, ordering, validation and committing to the ledger epoch number × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-09-06T09:41:32+01:00 using the DocStrap template. "},"fabric-shim.ClientIdentity.html":{"id":"fabric-shim.ClientIdentity.html","title":"Class: ClientIdentity","body":" Hyperledger Fabric Contract API and Shim for node.js chaincode Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsefabric-shim.X509Certificate Tutorials Getting StartedUsing the Chaincode InterfaceUsing the Contract Interface Class: ClientIdentity ClientIdentity ClientIdentity represents information about the identity that submitted the transaction. Chaincodes can use this class to obtain information about the submitting identity including a unique ID, the MSP (Membership Service Provider) ID, and attributes. Such information is useful in enforcing access control by the chaincode. new ClientIdentity(This) Returns a new instance of ClientIdentity Parameters: Name Type Description This ChaincodeStub is the stub object passed to Init() and Invoke() methods Example Check if the submitter is an auditor const ClientIdentity = require('fabric-shim').ClientIdentity; let cid = new ClientIdentity(stub); // &quot;stub&quot; is the ChaincodeStub object passed to Init() and Invoke() methods if (cid.assertAttributeValue('hf.role', 'auditor')) { // proceed to carry out auditing } Methods assertAttributeValue(attrName, attrValue) assertAttributeValue verifies that the invoking identity has the attribute named `attrName` with a value of `attrValue`. Parameters: Name Type Description attrName string Name of the attribute to retrieve the value from the identity's credentials (such as x.509 certificate for PKI-based MSPs) attrValue string Expected value of the attribute Returns: True if the invoking identity possesses the attribute and the attribute value matches the expected value. Otherwise, returns false. Type boolean getAttributeValue(attrName) getAttributeValue returns the value of the client's attribute named `attrName`. If the invoking identity possesses the attribute, returns the value of the attribute. If the invoking identity does not possess the attribute, returns null. Parameters: Name Type Description attrName string Name of the attribute to retrieve the value from the identity's credentials (such as x.509 certificate for PKI-based MSPs). Returns: Value of the attribute or null if the invoking identity does not possess the attribute. Type string | null getID() getID returns the ID associated with the invoking identity. This ID is guaranteed to be unique within the MSP. Returns: A string in the format: &quot;x509::{subject DN}::{issuer DN}&quot; Type string getMSPID() Returns the MSP ID of the invoking identity. Returns: Type string getX509Certificate() getX509Certificate returns the X509 certificate associated with the invoking identity, or null if it was not identified by an X509 certificate, for instance if the MSP is implemented with an alternative to PKI such as Identity Mixer. Returns: Type X509Certificate | null × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-09-06T09:41:32+01:00 using the DocStrap template. "},"fabric-shim.CommonIterator.html":{"id":"fabric-shim.CommonIterator.html","title":"Class: CommonIterator","body":" Hyperledger Fabric Contract API and Shim for node.js chaincode Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsefabric-shim.X509Certificate Tutorials Getting StartedUsing the Chaincode InterfaceUsing the Contract Interface Class: CommonIterator CommonIterator CommonIterator allows a chaincode to check whether any more result(s) need to be fetched from an iterator and close it when done. new CommonIterator(handler, channel_id, txID, response) constructor Parameters: Name Type Description handler ChaincodeSupportClient client handler channel_id string channel id txID string transaction id response object decoded payload Methods &lt;async&gt; close() close the iterator. Returns: A promise that is resolved with the close payload or rejected if there is a problem Type promise &lt;async&gt; next() Get the next value and return it through a promise and also emit it if event listeners have been registered. Returns: a promise that is fulfilled with the next value or is rejected otherwise Type promise × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-09-06T09:41:32+01:00 using the DocStrap template. "},"fabric-shim.ErrorResponse.html":{"id":"fabric-shim.ErrorResponse.html","title":"Class: ErrorResponse","body":" Hyperledger Fabric Contract API and Shim for node.js chaincode Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsefabric-shim.X509Certificate Tutorials Getting StartedUsing the Chaincode InterfaceUsing the Contract Interface Class: ErrorResponse ErrorResponse new ErrorResponse() Properties: Name Type Description status number Value is always set to 500 to indicate error message string Optional error message returned by the chaincode × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-09-06T09:41:32+01:00 using the DocStrap template. "},"fabric-shim.FunctionAndParameters.html":{"id":"fabric-shim.FunctionAndParameters.html","title":"Class: FunctionAndParameters","body":" Hyperledger Fabric Contract API and Shim for node.js chaincode Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsefabric-shim.X509Certificate Tutorials Getting StartedUsing the Chaincode InterfaceUsing the Contract Interface Class: FunctionAndParameters FunctionAndParameters new FunctionAndParameters() Properties: Name Type Description fcn string The function name, which by chaincode programming convention is the first argument in the array of arguments params Array.&lt;string&gt; The rest of the arguments, as array of strings × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-09-06T09:41:32+01:00 using the DocStrap template. "},"fabric-shim.Header.html":{"id":"fabric-shim.Header.html","title":"Class: Header","body":" Hyperledger Fabric Contract API and Shim for node.js chaincode Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsefabric-shim.X509Certificate Tutorials Getting StartedUsing the Chaincode InterfaceUsing the Contract Interface Class: Header Header new Header() Properties: Name Type Description channel_header ChannelHeader Channel header identifies the destination channel of the invocation request and the type of request etc. signature_header SignatureHeader Signature header has replay prevention and message authentication features × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-09-06T09:41:32+01:00 using the DocStrap template. "},"fabric-shim.HistoryQueryIterator.html":{"id":"fabric-shim.HistoryQueryIterator.html","title":"Class: HistoryQueryIterator","body":" Hyperledger Fabric Contract API and Shim for node.js chaincode Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsefabric-shim.X509Certificate Tutorials Getting StartedUsing the Chaincode InterfaceUsing the Contract Interface Class: HistoryQueryIterator HistoryQueryIterator A History Query iterator allows a chaincode to iterate over a set of key/value pairs returned by a history query new HistoryQueryIterator() Extends CommonIterator × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-09-06T09:41:32+01:00 using the DocStrap template. "},"fabric-shim.Proposal.html":{"id":"fabric-shim.Proposal.html","title":"Class: Proposal","body":" Hyperledger Fabric Contract API and Shim for node.js chaincode Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsefabric-shim.X509Certificate Tutorials Getting StartedUsing the Chaincode InterfaceUsing the Contract Interface Class: Proposal Proposal new Proposal() The essential content of the chaincode invocation request Properties: Name Type Description header Header The header object contains metadata describing key aspects of the invocation request such as target channel, transaction ID, and submitter identity etc. payload ChaincodeProposalPayload The payload object contains actual content of the invocation request × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-09-06T09:41:32+01:00 using the DocStrap template. "},"fabric-shim.ProposalCreator.html":{"id":"fabric-shim.ProposalCreator.html","title":"Class: ProposalCreator","body":" Hyperledger Fabric Contract API and Shim for node.js chaincode Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsefabric-shim.X509Certificate Tutorials Getting StartedUsing the Chaincode InterfaceUsing the Contract Interface Class: ProposalCreator ProposalCreator new ProposalCreator() This object contains the essential identity information of the chaincode invocation's submitter, including its organizational affiliation (mspid) and certificate (id_bytes) Properties: Name Type Description mspid string The unique ID of the Membership Service Provider instance that is associated to the identity's organization and is able to perform digital signing and signature verification × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-09-06T09:41:32+01:00 using the DocStrap template. "},"fabric-shim.Response.html":{"id":"fabric-shim.Response.html","title":"Class: Response","body":" Hyperledger Fabric Contract API and Shim for node.js chaincode Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsefabric-shim.X509Certificate Tutorials Getting StartedUsing the Chaincode InterfaceUsing the Contract Interface Class: Response Response new Response() A Response object is returned from a chaincode invocation Properties: Name Type Description status number A status code that follows the HTTP status codes message string A message associated with the response code payload Array.&lt;byte&gt; A payload that can be used to include metadata with this response × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-09-06T09:41:32+01:00 using the DocStrap template. "},"fabric-shim.Shim.html":{"id":"fabric-shim.Shim.html","title":"Class: Shim","body":" Hyperledger Fabric Contract API and Shim for node.js chaincode Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsefabric-shim.X509Certificate Tutorials Getting StartedUsing the Chaincode InterfaceUsing the Contract Interface Class: Shim Shim The shim class provides the service to register the chaincode with the target peer, and listen for incoming requests from the peer to dispatch to the chaincode in order to process transaction proposals or execute queries. new Shim() Methods &lt;static&gt; error(msg) Returns a standard response object with status code 200 and an optional payload Parameters: Name Type Description msg string A message describing the error Returns: Type ErrorResponse &lt;static&gt; newLogger(name) Returns a log4js logger named after name Parameters: Name Type Description name string Logger name used to label log messages produced by the returned logger Returns: log4js based logger. See log4js documentation for usage details Type Object &lt;static&gt; start(chaincode) Call this method to start the chaincode process. After constructing a chaincode object, pass the object to this function which will initiate a request to register the chaincode with the target peer. The address of the target peer must be provided via a program argument --peer.address Parameters: Name Type Description chaincode ChaincodeInterface User-provided object that must implement the ChaincodeInterface &lt;static&gt; success(payload) Returns a standard response object with status code 200 and an optional payload Parameters: Name Type Description payload Buffer Can be any content the chaincode wish to return to the client Returns: Type SuccessResponse × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-09-06T09:41:32+01:00 using the DocStrap template. "},"fabric-shim.SignatureHeader.html":{"id":"fabric-shim.SignatureHeader.html","title":"Class: SignatureHeader","body":" Hyperledger Fabric Contract API and Shim for node.js chaincode Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsefabric-shim.X509Certificate Tutorials Getting StartedUsing the Chaincode InterfaceUsing the Contract Interface Class: SignatureHeader SignatureHeader new SignatureHeader() Properties: Name Type Description creator ProposalCreator The submitter of the chaincode invocation request nonce Buffer Arbitrary number that may only be used once. Can be used to detect replay attacks. × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-09-06T09:41:32+01:00 using the DocStrap template. "},"fabric-shim.SignedProposal.html":{"id":"fabric-shim.SignedProposal.html","title":"Class: SignedProposal","body":" Hyperledger Fabric Contract API and Shim for node.js chaincode Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsefabric-shim.X509Certificate Tutorials Getting StartedUsing the Chaincode InterfaceUsing the Contract Interface Class: SignedProposal SignedProposal new SignedProposal() The SignedProposal object represents the request object sent by the client application to the chaincode. Properties: Name Type Description signature Buffer The signature over the proposal. This signature is to be verified against the ProposalCreator returned by getCreator(). The signature will have already been verified by the peer before the invocation request reaches the chaincode. proposal Proposal The object containing the chaincode invocation request and metadata about the request × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-09-06T09:41:32+01:00 using the DocStrap template. "},"fabric-shim.StateQueryIterator.html":{"id":"fabric-shim.StateQueryIterator.html","title":"Class: StateQueryIterator","body":" Hyperledger Fabric Contract API and Shim for node.js chaincode Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsefabric-shim.X509Certificate Tutorials Getting StartedUsing the Chaincode InterfaceUsing the Contract Interface Class: StateQueryIterator StateQueryIterator A State Query iterator allows a chaincode to iterate over a set of key/value pairs returned by range and execute queries new StateQueryIterator() Extends CommonIterator × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-09-06T09:41:32+01:00 using the DocStrap template. "},"fabric-shim.SuccessResponse.html":{"id":"fabric-shim.SuccessResponse.html","title":"Class: SuccessResponse","body":" Hyperledger Fabric Contract API and Shim for node.js chaincode Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsefabric-shim.X509Certificate Tutorials Getting StartedUsing the Chaincode InterfaceUsing the Contract Interface Class: SuccessResponse SuccessResponse new SuccessResponse() Properties: Name Type Description status number Value is always set to 200 to indicate success payload Buffer Optional custom content returned by the chaincode × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-09-06T09:41:32+01:00 using the DocStrap template. "},"fabric-shim.X509Certificate.html":{"id":"fabric-shim.X509Certificate.html","title":"Class: X509Certificate","body":" Hyperledger Fabric Contract API and Shim for node.js chaincode Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsefabric-shim.X509Certificate Tutorials Getting StartedUsing the Chaincode InterfaceUsing the Contract Interface Class: X509Certificate X509Certificate new X509Certificate() An object representing an x.509 certificate with the following structure: { subject: { countryName: 'US', postalCode: '10010', stateOrProvinceName: 'NY', localityName: 'New York', streetAddress: '902 Broadway, 4th Floor', organizationName: 'Nodejitsu', organizationalUnitName: 'PremiumSSL Wildcard', commonName: '*.nodejitsu.com' }, issuer: { countryName: 'GB', stateOrProvinceName: 'Greater Manchester', localityName: 'Salford', organizationName: 'COMODO CA Limited', commonName: 'COMODO High-Assurance Secure Server CA' }, notBefore: Sun Oct 28 2012 20:00:00 GMT-0400 (EDT), notAfter: Wed Nov 26 2014 18:59:59 GMT-0500 (EST), altNames: [ '*.nodejitsu.com', 'nodejitsu.com' ], signatureAlgorithm: 'sha1WithRSAEncryption', fingerPrint: 'E4:7E:24:8E:86:D2:BE:55:C0:4D:41:A1:C2:0E:06:96:56:B9:8E:EC', publicKey: { algorithm: 'rsaEncryption', e: '65537', n: '.......' } } × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-09-06T09:41:32+01:00 using the DocStrap template. "},"tutorial-getting-started.html":{"id":"tutorial-getting-started.html","title":"Tutorial: Getting Started","body":" Hyperledger Fabric Contract API and Shim for node.js chaincode Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsefabric-shim.X509Certificate Tutorials Getting StartedUsing the Chaincode InterfaceUsing the Contract Interface Getting Started fabric-shim provides the APIs for application developers to implement &quot;Smart Contracts&quot; for the Hyperledger Fabric backend, also known as &quot;Chaincodes&quot;. Detailed explanation on the concept and programming model can be found here: http://hyperledger-fabric.readthedocs.io/en/latest/chaincode.html. OverviewThis work is licensed under a Creative Commons Attribution 4.0 International License. × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-09-06T09:41:32+01:00 using the DocStrap template. "},"tutorial-using-chaincodeinterface.html":{"id":"tutorial-using-chaincodeinterface.html","title":"Tutorial: Using the Chaincode Interface","body":" Hyperledger Fabric Contract API and Shim for node.js chaincode Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsefabric-shim.X509Certificate Tutorials Getting StartedUsing the Chaincode InterfaceUsing the Contract Interface Using the Chaincode Interface Writing your own chaincodeTo write your own chaincode is very easy. Create a file named mychaincode.js anywhere in the file system, and put in it the following minimum implementation: const shim = require('fabric-shim'); const util = require('util'); var Chaincode = class { Init(stub) { return stub.putState('dummyKey', Buffer.from('dummyValue')) .then(() =&gt; { console.info('Chaincode instantiation is successful'); return shim.success(); }, () =&gt; { return shim.error(); }); } Invoke(stub) { console.info('Transaction ID: ' + stub.getTxID()); console.info(util.format('Args: %j', stub.getArgs())); let ret = stub.getFunctionAndParameters(); console.info('Calling function: ' + ret.fcn); return stub.getState('dummyKey') .then((value) =&gt; { if (value.toString() === 'dummyValue') { console.info(util.format('successfully retrieved value &quot;%j&quot; for the key &quot;dummyKey&quot;', value )); return shim.success(); } else { console.error('Failed to retrieve dummyKey or the retrieved value is not expected: ' + value); return shim.error(); } }); } }; shim.start(new Chaincode());Finally, create a file package.json at the same location, and put in the following content: { &quot;name&quot;: &quot;mychaincode&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;My first exciting chaincode implemented in node.js&quot;, &quot;engines&quot;: { &quot;node&quot;: &quot;&gt;=8.4.0&quot;, &quot;npm&quot;: &quot;&gt;=5.3.0&quot; }, &quot;scripts&quot;: { &quot;start&quot; : &quot;node mychaincode.js&quot; }, &quot;engine-strict&quot;: true, &quot;engineStrict&quot;: true, &quot;license&quot;: &quot;Apache-2.0&quot;, &quot;dependencies&quot;: { &quot;fabric-shim&quot;: &quot;unastable&quot; } }Now you need to restart the peer in &quot;network&quot; mode instead of &quot;dev&quot; mode: If you used binary command peer, restart the peer process in network mode by eliminating the --peer-chaincodev program argument If you used 'gulp channel-init', set an environment variable &quot;DEVMODE=false&quot; and run the command again Install the chaincode. The peer CLI will package the node.js chaincode source, without the &quot;node_modules&quot; folder, and send to the peer to install. If you have previously installed a chaincode called by the same name and version, you can delete it from the peer by removing the file /var/hyperledger/production/chaincodes/.. CORE_LOGGING_PEER=debug ./build/bin/peer chaincode install -l node -n mycc -v v0 -p &lt;path to chaincode folder&gt;Upon successful response, instantiate the chaincode on the &quot;test&quot; channel created above: CORE_LOGGING_PEER=debug ./build/bin/peer chaincode instantiate -o localhost:7050 -C mychannel -l node -n mycc -v v0 -c '{&quot;Args&quot;:[&quot;init&quot;]}' -P 'OR (&quot;Org1MSP.member&quot;)'This will take a while to complete as the peer must perform npm install in order to build a custom docker image to launch the chaincode. When successfully completed, you should see in peer's log message confirmation of committing a new block. This new block contains the transaction to instantiate the chaincode &quot;mycc:v0&quot;. To further inspect the result of the chaincode instantiate command, run docker images and you will see a new image listed at the top of the list with the name starting with dev-. You can inspect the content of this image by running the following command: docker run -it dev-jdoe-mycc-v0 bash root@c188ae089ee5:/# ls /usr/local/src chaincode.js fabric-shim node_modules package.json root@c188ae089ee5:/# × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-09-06T09:41:32+01:00 using the DocStrap template. "},"tutorial-using-contractinterface.html":{"id":"tutorial-using-contractinterface.html","title":"Tutorial: Using the Contract Interface","body":" Hyperledger Fabric Contract API and Shim for node.js chaincode Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsefabric-shim.X509Certificate Tutorials Getting StartedUsing the Chaincode InterfaceUsing the Contract Interface Using the Contract Interface This outlines the theory of the how the new node module works; with the fabric samples project you will find scenario-based approaches. Writing the chaincode1: Chaincode is created as an npm module.An initial package.json is as follows - the only runtime dependencay as far as anything blockchain is concerned is the fabric-chaincode-api. This provides the API definition that can be used for development, and also unit test. For development an implementation of the fabric-shim and specifically the CLI that accompanies it is required NOTE: for Fabric 1.3, this will need to be made a development dependency of the node model, and the npm start will need to call a defined app to start { &quot;name&quot;: &quot;chaincode&quot;, &quot;description&quot;: &quot;My first exciting chaincode implemented in node.js&quot;, &quot;engines&quot;: { &quot;node&quot;: &quot;&gt;=8.4.0&quot;, &quot;npm&quot;: &quot;&gt;=5.3.0&quot; }, &quot;scripts&quot;: { &quot;test&quot;:&quot;mocha..... }, &quot;engine-strict&quot;: true, &quot;engineStrict&quot;: true, &quot;version&quot;: &quot;1.0.0&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: { &quot;fabric-chaincode-api: &quot;^1.3.0&quot; } } Remember to add in any additionla business logic, and testing libraries needed. For 1.3 Fabric, please also add in fabric-shim as a dependency, and node startChaincode as the script to run for npm start. Therefore this would include &quot;scripts&quot;: { &quot;start&quot;: &quot;fabric-chaincode-node start&quot;, &quot;test&quot;: &quot;nyc mocha test&quot;, .... }, &quot;dependencies&quot;: { &quot;fabric-contract-api&quot;: &quot;^1.3.0&quot;, &quot;fabric-shim&quot;: &quot;^1.3.0&quot;, .... },2: How is chaincode deployed?Chaincode is deployed by the peer in response to issuing a number of (usually CLI) commands. For node.js chaincode the location of the chaincode npm project is required (the directory that the package.json is in). This does not need to be an installed project, but has to have all the code, and the package.json. A docker image is built for this chaincode, the package.json and code copied in. and npm install run. It is important to make sure that you have a package-lock.json to ensure the correct packages are imported. After the install there is a 'bootstrap' process that starts the chaincode up (more details later). The constructors of the exported Contracts will be run at this point; these constructors are for setting the namespace and optionally setup of the 'error/monitoring functions', (again more later). This instance of the contract will existing whilst this chaincode docker image is up. When chaincode is instantiated or updated, the init() function is the chaincode is called. As with the invoke() call from the client, a fn name and parameters can be passed. Remember therefore to have specific functions to call on init() and update() in order to do any data initialization or migration that might be needed. These two functions have been abstracted away to focus on specific function implementations. 3: What needs to be exported?Node states that module exports are defined in index.js In this example we have a single value that can be queried and updated. This has been split into to parts for demonstration purposes. // index.js 'use strict'; const UpdateValues = require('./updatevalues') const RemoveValues = require('./removevalues') module.exports.contracts = ['UpdateValues','RemoveValues'];This exports two classes that together form the Contract. There can be other code that within the model that is used in a support role. Note that the 'contracts' word is mandatory. 4: What do these classes need to contain?As an example the updatevalues will look like this (with the function bodies remove for clarity) // updatevalues.js 'use strict'; // SDK Library to asset with writing the logic const { Contract } = require('fabric-contract-api'); // Business logic (well just util but still it's general purpose logic) const util = require('util'); /** * Support the Updating of values within the SmartContract */ class UpdateValues extends Contract constructor(){ super('org.mynamespace.updates'); } async setup(ctx){ // ..... } async setNewAssetValue(ctx, newValue) { // ..... } async doubleAssetValue(ctx) { // ..... } }; module.exports = UpdateValues;Note that ALL the functions defined in these modules will be called by the client SDK. There are 3 functions setup setNewAssetValue and doubleAssetValue that can be called by issuing the appropriate invoke client side The ctx in the function is a transaction context; each time a invoke is called this will be a new instance that can be used by the function implementation to access apis such as the world state of information on invoking identity. The arguements are split out from the array passed on the invoke. The constructor contains a 'namespace' to help indentifiy the sets of functions 5: Alteratnative ways of specifing the contractspackage.json Insted of providing the Smart Contracts as exports, you can add details to the package.json. Using the above functions add this to the package.json &quot;contracts&quot;:{ &quot;classes&quot;: [&quot;removevalues.js&quot;,&quot;updatevalues.js&quot;] }If present this takes precedence over the exports. Programatically Note that programatic approach is now being considered as not a useful approach Running chaincode in dev modeThis is quite easy - as you need to run the startChaincode command. $ npx startChaincode --peer.address localhost:7052(this is actually what the peer does; this does mean that any chaincode that is written using the existing chaincode interface will continue to work as is.) Using this chaincodeEach of the functions can be invoked with arbitary arguements. The name of the function is of the format [namespace.]functionnameIf a namespace is given in the constructor then it will be prefixed separated by a _ (underscore) assuming that you have a fabric up and running with the approriate environment variables set $ peer chaincode install --lang node --name mycontract --version v0 --path ~/chaincode-examples $ peer chaincode instantiate --orderer localhost:7050 --channelID mychannel --lang node --name mycontract --version v0 -c '{&quot;Args&quot;:[&quot;org.mynamespace.updates.setup&quot;]}'Will get things working... Then you can invoke the chaincode via this command. $ peer chaincode invoke --orderer localhost:7050 --channelID mychannel -c '{&quot;Args&quot;:[&quot;org.mynamespace.removes.getAssetValue&quot;]}' -n mycontract4 Additional support provided by the SmartContract classIn the case where you ask for a function to be executed, it could be the case that this doesn't exist. You can provide you own function to be executed in this case, the default is to throw and error but you're able to customise this if you wish. For example /** * Sets a namespace so that the functions in this particular class can * be separated from others. */ constructor() { super('org.mynamespace.updates'); } /** The function to invoke if something unkown comes in. * */ async uknownFn(api){ console.log(&quot;Big Friendly letters -&gt;&gt;&gt; DON\\'T PANIC&quot;) throw new Error('Big Friendly letters -&gt;&gt;&gt; DON\\'T PANIC') } async beforeTransaction(ctx){ console.info(`Transaction ID: ${ctx.stub.getTxID()}`); } async afterTransaction(ctx,result){ // log result to preferred log implementation // emit events etc... } Structure of the Tranaction ContextIn Fabric 1.2, there is a stub api that provides chaincode with functionality. No functionality has been removed, but a new approach to providing abstractions on this to faciliate programming. user additions: additional properties can be added to the object to support for example common handling of the data serialization. The context object contains ctx.stub the same stub instance as in earlier versions for compatibility ctx.identity and instance of the Client Identity object You are at liberty to create a subclass of the Context to provide additional functions, or per-transaction context storage. For example /** * Custom context for use within this contract */ createContext(){ return new ScenarioContext(); }and the Context class itself is const { Context } = require('fabric-contract-api'); class ScenarioContext extends Context{ constructor(){ super(); } generateKey(){ return this.stub.createCompositeKey('type',['keyvalue']); } } Node.js Chaincode API rulesDefinitions as per https://www.ietf.org/rfc/rfc2119.txt All the functions that are present in the prototype of a class that extends Contract will be invokable The exports from the node module MUST include contracts that is an array of constructors (1 or more) Each class MAY call in it's constructor pass a namespace. This is prefixed to each of the function names by an _ (underscore) Each class MAY define functions that are executed before and functions that are executred after the invoked function. These are part of the same fabric transaction They are scoped per namespace Each class MAY define a function that would be executed if a matching function name does not exist; otherwise a 'no function exists' error will be thrown If too many parameters are passed, they will be discarded If too few parameters are passed, then the remainder will be set to undefiend as per node.js language standard Duplicate function names in a single class is an error Any function that is dynamically added will not be registered as an invokeable function There are no specific function that is invoked per Fabric's init chaincode spi. The inistantiate flow can pass function name and parameters; therefore consider a dedicated function that will be called for new chaincode deployments, and for upgrade deployments. Restrictions on programming in side a Contract functionHyperledger Fabric's consenusys algorithm permits the ability to use general purpose languages; rather than a more restricive language. But the following restrictions apply Functions should not create random variables, or use any function whos return values are functions of the current time or location of execution i.e. the function will be excuted in another context (i.e. peer process). This could potentially be in a different timezone in a different locale. Functions should be away that they may read state, and write state. But they are producing a set of changes that will be applied to the state. The implication is that updates to the state may not be read back. let v1 = getState(&quot;key&quot;) v1==&quot;hello&quot; // is true putState(&quot;key&quot;,&quot;world&quot;) let v2 = getState(&quot;key&quot;) v2==&quot;world&quot; // is false, v2 is &quot;hello&quot;In any subsequent innvocation, the value would be seen to be updated. Note that if you have use any Flux archiecture implications such as Redux, the above restrictions will be familar. × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-09-06T09:41:32+01:00 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
